#!/usr/bin/python3
#  Copyright (c) 2021 Zubax, zubax.com
#  Distributed under the MIT License, available in the file LICENSE.
#  Author: Silver Valdvee <silver.valdvee@zubax.com>
import argparse
import os
from os import walk
import platform
import re
from pathlib import Path
import builtins as __builtin__
import importlib

try:
    colored_spec = importlib.util.find_spec("termcolor")
    if colored_spec is not None:
        from termcolor import colored
    else:
        def colored(input_string, _):
            return input_string
except AttributeError:
    print("Your \"importlib\" module does not have the attribute \"util\",")
    print("this only affects colors in this application.")
    def colored(input_string, _):
            return input_string
verbose = False
do_dump = False
dump_path = ""
path_from_arguments = ""
use_compound_named_file = False
use_command_without_verification = False

tempFile = """target extended-remote $PORT
mon swdp_scan
attach 1
load
kill
quit"""

tempFileDump = """target extended-remote $PORT
mon swdp_scan
attach 1
load
dump bin mem $PATH_DUMP 0x08000000 0x08040000
kill
quit"""


def say(*args, **kwargs):
    __builtin__.print(*args, **kwargs)


def print(*args, **kwargs):
    if verbose:
        __builtin__.print(*args, **kwargs)


def yes_or_no(message):
    answer = input(f"{message} (Y/n)")
    if str.lower(answer) == "n":
        return False
    return True


def follow_link(link):
    print(f"The link is at: {str(link)}")
    actual_location = os.readlink(str(link))
    print(f"{actual_location} is the actual location of the port found.")
    new_actual_location = actual_location
    try:
        while True:
            new_actual_location = os.readlink(actual_location)
            if new_actual_location == actual_location:
                break
            else:
                actual_location = new_actual_location
                print("A link hop was done.")
        print(f"{new_actual_location} was followed from links.")
    except FileNotFoundError:
        pass
    print(f"Now {link} {actual_location}")
    return os.path.normpath(os.path.join(os.path.dirname(link), actual_location))


def get_port():
    if "Linux" in platform.uname().system:
        if path_from_arguments:
            if should_be_resolved(path_from_arguments):
                return follow_link(path_from_arguments)
            else:
                return path_from_arguments
        pattern = re.compile(r".*Black.*Magic.*Probe.*$")
        chosenPath = r"/dev/serial/by-id/"
        files = next(walk(Path(chosenPath)), [(None, None, [])])[2]
        my_filter = lambda x: pattern.search(str(x))
        files = list(filter(my_filter, files))
        if len(files) > 1:
            enumerated_files = list(enumerate(files, 1))
            say("Select a port:")
            for index, file in enumerated_files:
                colored_index = colored(str(index), "yellow")
                colored_file_name = colored(file, "blue")
                say(f"nr {colored_index}. port name: {colored_file_name}")
            requested_nr = -10030
            while not (len(enumerated_files) > requested_nr > -1):
                requested_nr = int(input("Enter the number of the port you would like to be selected: ")) - 1
                if requested_nr != -10030:
                    say(f"Number out of range. Please choose a number between: 1 and {len(enumerated_files)}.")
            requested_file = enumerated_files[requested_nr][1]
        elif len(files) == 1:
            requested_file = files[0]
        else:
            say("No ports are available. Make sure the blackmagic device is connected.")
            exit(1)
        say(f"Requested file {requested_file} will be uploaded.")
        files = [requested_file]
        print("Here are the files " + " ".join(files))
    elif "Darwin" in platform.uname().system:
        raise NotImplemented(f"Platform {platform.uname().system} not supported yet.")
    else:
        raise NotImplemented(f"Platform {platform.uname().system} not supported yet.")
    return follow_link(os.path.join(chosenPath, str(files[0])))


def upload_file(port_file, elf_file, gdb_name, size_name):
    if port_file is None:
        say("Use option -sp to select a port. Cannot continue without.")
        exit(1)
    stream = os.popen(f"{size_name} {elf_file}")  # arm-none-eabi-size $elf
    output = stream.read()
    if do_dump:
        say("The dump command has built in memory ranges for stm32f105r8 according to its memory mapping."
            "\nIf you are using this script to dump any other memory range then please change the range in the script.")
        if len(dump_path):
            temp_file2 = tempFileDump.replace("$PORT", port_file).replace("$PATH_DUMP", dump_path)
        else:
            print("You did not specify a dumpPath.")
    else:
        temp_file2 = tempFile.replace("$PORT", port_file)
    arguments = []
    for line in temp_file2.split("\n"):
        arguments.append(f"-ex \"{line.rstrip()}\"")  # https://manned.org/arm-none-eabi-gdb/7308522e

    argument_string = " ".join(arguments)
    upload_command = f"{gdb_name} {elf_file} {argument_string} -nh --batch"
    if use_command_without_verification or yes_or_no(f"Should the upload command be run: {upload_command}"):
        stream = os.popen(upload_command)  # arm-none-eabi-size $elf
        output = stream.read()
        print(output)
    else:
        print("You didn't want to execute the command")
        exit(1)


def get_needed_elf_file(directory):
    files = next(walk(Path(directory)), (None, None, []))
    files = files[2]
    files = filter(lambda x: str(x).endswith(".elf"), files)
    enumerated_files = list(enumerate(files))
    say()
    requested_nr = None
    if len(enumerated_files) > 1:
        say("No input files were specified, now looking for elf files, would like to use any of them?")
        for index, file in enumerated_files:
            colored_index = colored(str(index), "yellow")
            print(f"use_compound_named_file = {use_compound_named_file}")
            if use_compound_named_file and "compound" in file:
                say("This is the file!")
                requested_nr = index
            colored_file_name = colored(file, "blue")
            say(f"nr {colored_index}. file name: {colored_file_name}")
        if requested_nr is None:
            requested_nr = int(input("Enter the number of the file you would like to be uploaded: "))
        if len(enumerated_files) > requested_nr > -1:
            requested_file = enumerated_files[requested_nr][1]
            say(f"Requested file {requested_file} will be uploaded.")
            return requested_file
    elif len(enumerated_files) == 1:
        # say("No input files were specified.")
        say("One elf file is available.")
        file_name = colored(enumerated_files[0][1], "blue")
        if not yes_or_no(f"Use {file_name}?"):
            say("You didn't select an elf file.")
            exit(1)
        else:
            return enumerated_files[0][1]
    else:
        if directory == os.getcwd():
            say("There are no elf files in the current working directory.")
        else:
            say(f"There are no elf files in: {directory}")
        exit(1)


def no_given_file_scenario(directory):
    return get_needed_elf_file(directory), get_port()


def file_given_scenario(file):
    return file, get_port()


def should_be_resolved(path):
    return "by-" in str(path)


def main():
    global verbose, do_dump, dump_path, select_port, path_from_arguments, use_compound_named_file, use_command_without_verification
    say("A utility for Droncode probe.")
    print(platform.uname())
    if "Linux" not in platform.uname().system:
        # TODO: The reference sh script had support for Darwin too
        raise Exception("Only linux distributions are supported")
    try:
        parser = argparse.ArgumentParser(description='Upload a new binary to the microcontroller through blackmagic.')
        parser.add_argument('dir', nargs='?', default=os.getcwd(),
                            help="Searching for the elf file in this directory."
                                 " Defaults to the current working directory.")
        parser.add_argument('-i', '--input_file', help='an elf file to read in')
        parser.add_argument('-g', '--gdb-executable', default="arm-none-eabi-gdb")
        parser.add_argument('-s', '--size-executable', default="arm-none-eabi-size")
        parser.add_argument('-v', '--verbose', default=False, action='store_true')
        parser.add_argument('-d', '--dump', default=False, action='store_true')
        parser.add_argument('-uc', '--use-compound', default=False, action='store_true',
                            help="use compound.elf without asking")
        parser.add_argument('-up', '--use-port', help="The port or link to the port to use.")
        parser.add_argument('-pp', '--print-port', default=False, action='store_true')
        parser.add_argument('--dump-path', default=os.path.join(os.path.expanduser('~'), "magicdump.bin"))
        parser.add_argument('-y', '--yes', default=False, action='store_true')
        args = parser.parse_args()
        use_command_without_verification = args.yes
        use_compound_named_file = args.use_compound
        path_from_arguments = args.use_port
        if args.print_port:
            say(get_port())
            exit(0)
        is_absolute = os.path.isabs(args.dir)
        if args.dir != os.getcwd() and not is_absolute:
            args.dir = os.path.join(os.getcwd(), args.dir)
        verbose = args.verbose
        do_dump = args.dump
        dump_path = args.dump_path
        if args.input_file:
            file, port = file_given_scenario(args.input_file)
        else:
            file, port = no_given_file_scenario(args.dir)
            file = os.path.join(args.dir, file)
        if not Path(file).exists():
            print("Your specified file doesn't exist.")
            exit(1)
        print(args)
        upload_file(port, file, args.gdb_executable, args.size_executable)
    except KeyboardInterrupt:
        print(os.linesep + 'Okay, good luck!')


if __name__ == '__main__':
    main()
